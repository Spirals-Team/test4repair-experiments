
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.json.simple.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.commons.io.FileUtils;

import core.Config;
import core.Project;
import core.tools.Nopol;
import processors.ExtractFailingTestsProcessor;
import processors.RemoveEvosuiteEffectsProcessor;
import processors.TestSelectionProcessor;

import spoon.Launcher;
import spoon.compiler.ModelBuildingException;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtType;

public class runNodeMode {
	
	private static int identifyNumber;
	private static Project toRepair;
	public final  static Logger logger = LoggerFactory.getLogger(runNodeMode.class);
	public static List<CtMethod<?>>  keptMethods = new ArrayList<CtMethod<?>>();
	public static List<CtMethod<?>>  singleMethod = new ArrayList<CtMethod<?>>();
	public static List<CtMethod<?>>  sucessMethod = new ArrayList<CtMethod<?>>();
    private static Nopol repairTool;
	private static String testPath="";
	private static int maximalRepairTime=40;
	
	private static int[] seed= {4, 12, 18, 26, 28, 35, 41, 54, 60, 66, 
			75, 83, 98, 100, 104, 111, 113, 120, 128, 135, 
			143, 150, 153, 161, 166, 173, 180, 181, 186, 193};

	private static String initialPatchString;
	private static long nopolFastRepairTime=0;
	private static long nopolSimpleRepairTime=0;
	public static void main(String[] args) {
		  startRepair();
	}
	
	/**
	  * runs repair for the buggy versions in the Defects4j repository
	  */
	public static void startRepair() {

		   prepareRepository.downloadRepository();

	        String projectName;
		    // repair JFreechart buggy versions
		    
		    projectName = "Chart";
		    toRepair = new Project (projectName);
			Project.parseData(projectName);
		    for (int chartID=1; chartID <=26; chartID++)
	   	    {
		      if(chartID==1||chartID==5||chartID==9||chartID==13||chartID==15||chartID==17
	               ||chartID==21||chartID==25||chartID==26)
		      {
			    identifyNumber= chartID;
			    runNopolRepair();
		      }
	   	    }
		    
		    // repair Apache commons-lang buggy versions
		    
		    projectName = "Lang";
		    toRepair = new Project (projectName);
			Project.parseData(projectName);
	   	    for(int LangID=1; LangID <=65; LangID++)
		    {
	   	    	 if(LangID==44||LangID==51||LangID==53||LangID==55||LangID==58||LangID==63)		
	   	    	{
			      identifyNumber= LangID;
				  runNopolRepair();
	   	    	}
		    }
	   	    
	   	    // repair Apache commons-math buggy versions
	   	    
	   	    projectName = "Math";
		    toRepair = new Project (projectName);
			Project.parseData(projectName);
	   	    for (int MathID=1; MathID <=106; MathID++)
		    {
	   	    	if(MathID==7||MathID==24||MathID==28||MathID==33||MathID==40||MathID==41||MathID==42||MathID==44||MathID==49
	   	    	||MathID==50||MathID==57||MathID==58||MathID==69||MathID==71||MathID==73||MathID==78||MathID==80   	    			
	   	    			||MathID==81||MathID==82||MathID==84||MathID==85||MathID==87||MathID==88||MathID==105)
	   	    	 {
			       identifyNumber= MathID;
			       runNopolRepair();
	   	    	 }
		    }
  	      
	   	   //  repair Joda-Time buggy versions 
	   	     
	   	    projectName = "Time";
		    toRepair = new Project (projectName);
			Project.parseData(projectName);
	   	    for (int TimeID=1; TimeID <=27; TimeID++)
		    {
	   	    	if(TimeID==4||TimeID==7||TimeID==11||TimeID==14||TimeID==16)
	   	    	{
			     identifyNumber= TimeID;
				 runNopolRepair();
	   	    	}
		    }    
	}
	
	/**
     * run nopol to repair programs, NopolC generates bug fixes by making changes to condition, NopolC generates
     * bug fixes by adding precondition
     */
	public static void runNopolRepair() {
				  
		  repairTool = new Nopol ("Nopol");
		  repairTool.parseData("nopol");
		  maximalRepairTime = 40;
		  repairTool.run(toRepair, identifyNumber, true, false, true, null, maximalRepairTime);
		
		  /**
		   * gets some information from the initial run of nopol, including the name of the class that contains
		   * the fix (rootClassName), the temporary working directory (workDir), and the class path of the project
		   * (projectClassPath) under repair. Additionally, uses the temporary working directory to construct the 
		   * folder that contains the test cases generated by EvoSuite (destTestFolder and destSrcTestFolder, note
		   * destSrcTestFolder contains tests processed by spoon according to some processors) and the folder that
		   * contains the compiled test cases (destCpTestFolder). 
		   */
		 String rootClassName = repairTool.getRootClassName();
		 String projectClassPath=repairTool.getProjectClassPath();
		 String workDir = repairTool.getWorkDir();
		 
		 initialPatchString = repairTool.getPatchString();
		 String transformedTestFoler = workDir + "/transformedTests";
		 	 
		 String tempTestFolder = workDir + "/temptests";
		 String tempFailingTestFolder = workDir + "/tempFailingtests";
		 String tempCPFailingTestFolder = workDir + "/tempCPFailingtests";
		 String destSrcTestFolder = workDir + "/";
		 destSrcTestFolder += repairTool.getSourceTestsPath();
		 
		 String destCpTestFolder = workDir + "/";
		 destCpTestFolder += repairTool.getCompiledTestsPath();
		 
		 /**
		   * If the initial run of nopol returns a bug fix, uses EvoSuite to generate tests to improve 
		   * the bug fix, 
		   */
		 if (!(rootClassName.equals(""))&&!(rootClassName==null)) { 
			 int allowedRepairTime = (int)Math.ceil(2*repairTool.getRepairTime());
			 for (int index=0; index<seed.length;index++) {
		       String generatedTestFolder= repairTool.getFinalLogPath() + "/"+Integer.toString(seed[index])+"/generatedTests";
		       String testFolderNopolFast= repairTool.getFinalLogPath() + "/"+Integer.toString(seed[index])+"/testForNopolFast";
		       String testFolderNopolSimple= repairTool.getFinalLogPath() + "/"+Integer.toString(seed[index])+"/testForNopolSimple";
		       String testFolderSuccess= repairTool.getFinalLogPath() + "/"+Integer.toString(seed[index])+"/testSuccess";
			   tryRepairWithEvoSuite(seed[index], generatedTestFolder, tempTestFolder, destCpTestFolder, 
		    		transformedTestFoler, projectClassPath, rootClassName, workDir, destSrcTestFolder,tempFailingTestFolder,tempCPFailingTestFolder,allowedRepairTime
		    		,testFolderSuccess,testFolderNopolFast,testFolderNopolSimple);
			 }
		 }
	}
	
	public static String processOrginalString (String orginalPathOfEvosuitePath) {
		
		String finalPathOfEvosuitePath = "";
		String[] indexArray=orginalPathOfEvosuitePath.split("/");
		int startindx=0;
		for (int index=0;index<indexArray.length;index++)
		{
			if(indexArray[index].equals("org"))
			{
				startindx=index;
				finalPathOfEvosuitePath = indexArray[index];
				finalPathOfEvosuitePath += ".";
			}
			
			if(startindx>0 && index>startindx)
			{
				finalPathOfEvosuitePath += indexArray[index];
				if(index!=(indexArray.length-1))
				{
					finalPathOfEvosuitePath+=".";
				}
			}
		}
		finalPathOfEvosuitePath=finalPathOfEvosuitePath.replace(".java", "");
		return finalPathOfEvosuitePath;
		
	}
	
	 /**
     * Generate evosuite test on newTestFolder for the class ClassName on the project classPath
     * @param newTestFolder contains the test cases generated by EvoSuite
     * @param classPath name of class path
     * @param className name of the class that contains the fix 
     * @return newTestFolder
     */
	public static long generateEvoSuiteTests(int seed, String newTestFolder, String classPath, String className){
		
		String evosuitePath=repairTool.getEvoSuitePath();
		
		String commandString="";
		
		commandString = "cd "+ repairTool.getWorkDir()+" && ";
		
		/**
	     * adds jdk8 path to PATH, note latest EvoSuite currently uses jdk version 8
	     */
		commandString += "export PATH=";
		commandString += Config.processPath(System.getenv("PATH"),8);
		commandString += " && ";
		
		/**
	     * some parameters for EvoSuite. In particular, seed is used for the random number generator (when not specified, 
	     * EvoSuite will use a new random seed every time it is called)
	     */

		String evosuiteString="";
		
		evosuiteString = "java "+" -jar "+evosuitePath+" -class "+className+" -projectCP "+classPath+" -seed "+Integer.toString(seed)+
	               " -Dassertion_timeout=1800 "+"-Dminimization_timeout=1800 "+"-Djunit_check_timeout=1800 "+
				   "-Dwrite_junit_timeout=300 "+ "-Dinitialization_timeout=300 "+"-Dglobal_timeout=18000 "+
	               "-Dsearch_budget=100000 "+"-Dstopping_condition=MaxStatements "+"-Dno_runtime_dependency=true "
				   +"-Dsandbox=false "+"-Dp_reflection_on_private=0.0 -Dreflection_start_percent=1.0 "
				    + "-Dp_functional_mocking=0.0 -Dfunctional_mocking_percent=1.0 "+"-mem 2000 "+" -Dtest_dir="+newTestFolder;
		commandString += evosuiteString;
		
        /**
	     * starts a shell process to run EvoSuite
	     */
        String[] cmd = { "/bin/bash", "-c", commandString};
	    ProcessBuilder pb = new ProcessBuilder(cmd);
	    pb.redirectErrorStream(true);
        Process p = null;
        long elapsedTime = 0;
        try {
           // pb.inheritIO();
        	long startTime = System.nanoTime();
            p = pb.start();
            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String s = null;
			FileOutputStream fos= null;
			BufferedWriter bw = null;
			File file = new File(repairTool.getLogInfoBase()+Integer.toString(seed)+"/evosuite.log");
			fos = new FileOutputStream(file);
			bw = new BufferedWriter(new OutputStreamWriter(fos));
			while ((s = stdInput.readLine()) != null) {
					 bw.write(s);
				     bw.newLine();
		     }		
			bw.close();
            p.waitFor();
            long stopTime = System.nanoTime();
            elapsedTime = stopTime - startTime;
         } catch (IOException e1) {
            e1.printStackTrace();
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
        return elapsedTime;
        
    }
	
    /**
     * this method analyzes all java class in generatedTestDir and returns a list of all Junit methods
     * @param generatedTestFolder
     * @param classPath 
     * @return List<CtMethod> list of methods
     */
    public static List<CtMethod<?>> getNewTestsMethods(String generatedTestFolder, String classPath){
    	
        List<CtMethod<?>>  testsMethods = new ArrayList<CtMethod<?>>();
        logger.debug("--------------------------------------------------");
        logger.debug(" ##### Search tests methods ##### ");
        Launcher spoon = new Launcher();
        spoon.getEnvironment().setAutoImports(true);
        spoon.addInputResource(generatedTestFolder);
        spoon.getEnvironment().setSourceClasspath(classPath.split(File.pathSeparator));
        spoon.buildModel();
        Boolean whetherAlreadyIncluded=false;
        for(CtType<?> clazz : spoon.getFactory().Class().getAll()){
                for(CtMethod<?> method : clazz.getAllMethods()) {
                    for(CtAnnotation<? extends Annotation> annotation : method.getAnnotations()){
                        if(annotation.getSignature().equals("@org.junit.Test")){
                        	whetherAlreadyIncluded=false;
                            logger.debug("[FOUND] "+method.getSignature());
                            for (int index=0;index<testsMethods.size();index++)
                            {
                            	if(testsMethods.get(index).getSignature().equals(method.getSignature())) {
                            		whetherAlreadyIncluded=true;
                            		break;
                            	}
                            }
                            if(!whetherAlreadyIncluded)
                               testsMethods.add(method);
                     }
                 }
            }
        }
        return testsMethods;
    }
    
    /**
     * gets the absolute path of the original class path
     * @param orginalProjectPath : the original class path, which in fact are mostly relative
     * @param prefixWorkDir : the temporary working directory
     */
    public static String getNewProjectPath (String orginalProjectPath, String prefixWorkDir) {
    	
    	String[] pathArray=orginalProjectPath.split(File.pathSeparator);
    	String newProjectClassPath="";
    	for (int index=0; index<pathArray.length;index++)
    	{
    		String currentPath="";
    		if (pathArray[index].startsWith("/"))
    		{
    			currentPath = pathArray[index];
    		}
    		else
    		{
    		    currentPath=prefixWorkDir+"/"+pathArray[index];
    		}
    		newProjectClassPath+=currentPath;
    		if (!(index==(pathArray.length-1)))
    			newProjectClassPath+=File.pathSeparator;
    	}
    	return newProjectClassPath;	
     } 
    
    @SuppressWarnings("unchecked")
	public static void logEvosuiteRepairInfo (int seed, int nbEvoGenMethod, long evoGenTime, long evoRepairTime, int nbRemovedMethod, 
    		int nbDiscardedJDK8Tests, String patchString, int nbFailingEvosuiteTests, int nbFlakyTests, String strategyUsed)
    {
    	/**
	     * writes the evo Repair result to json file
	     */
    	String className = null;
    	int lineNumber = 0;
    	String patchType = null;
    	String patch = null;
		String patternString = "([^:]+):([0-9]+): ([^ ]+) (.+)";
		Pattern pattern = Pattern.compile(patternString);
        Matcher m= pattern.matcher(patchString);
        if (m.find())
        {
       	 className = m.group(1);
       	 lineNumber = Integer.parseInt(m.group(2));
       	 patchType = m.group(3);
       	 patch = m.group(4);
        }
        
		JSONObject obj = new JSONObject();
		obj.put("nbEvoGenMethod", nbEvoGenMethod);
		obj.put("evoGenTime", evoGenTime);
		obj.put("evoRepairTime", evoRepairTime);
		obj.put("nbRemovedMethod", nbRemovedMethod);
		obj.put("nbDiscardedJDK8Tests", nbDiscardedJDK8Tests);
		obj.put("nbFailingEvosuiteTests", nbFailingEvosuiteTests);
		obj.put("nbFlakyTests", nbFlakyTests);
		
		JSONObject subobj = new JSONObject();
		subobj.put("className", className);
		subobj.put("line", lineNumber);
		subobj.put("patchType", patchType);
		subobj.put("patch", patch);
		obj.put("patchInfo", subobj);
		
		try {
			FileWriter file1 = new FileWriter(repairTool.getFinalLogPath()+"/"+Integer.toString(seed)+"/evo-repair-result-"+strategyUsed+".json");
			file1.write(obj.toJSONString());
			file1.flush();
			file1.close();
		} catch (IOException e) {
			e.printStackTrace();
		}	
    }
    
    public static ArrayList<String> getFailingTests(){
    	
    	ArrayList<String>  failingTests = new ArrayList<String>();
        String workDir=repairTool.getWorkDir();
		workDir+="/failing_tests";
		FileInputStream fis = null;
        BufferedReader reader = null;
        try {
            fis = new FileInputStream(workDir);
            reader = new BufferedReader(new InputStreamReader(fis));
            String line;
            while ((line = reader.readLine()) != null) {
            	if (line.contains("--- "))
            	{
            		line=line.trim();
            		line=line.replace("--- ", "");
            		failingTests.add(line);
            	}
            }
            reader.close();
            fis.close();
        } catch (FileNotFoundException ex) {
        	ex.printStackTrace();} 
        catch (IOException ex) {
        	ex.printStackTrace();} 
        
        return failingTests;
    }

    public static String[] concat(String[] a, String[] b) {
    	
        int aLen = a.length;
        int bLen = b.length;
        String[] c= new String[aLen+bLen];
        System.arraycopy(a, 0, c, 0, aLen);
        System.arraycopy(b, 0, c, aLen, bLen);
        return c;
    }
    
    public static ArrayList<String> processFailingTests (ArrayList<String> failingTests) {
    	
    	ArrayList<String> returnedTest=new ArrayList<String>();
    	Boolean whetherExistedClass = false;
    	for (int number=0; number<failingTests.size();number++) {
    		whetherExistedClass = false;
    		String testString=failingTests.get(number);
    		if(number==0)
    		    returnedTest.add(testString);
    		else {
    			String[] testInfo = testString.split("::");
            	String testPath= testInfo[0];
            	String testMethod = testInfo[1];
            	for(int index=0; index<returnedTest.size(); index++) {
            		String existTestString = returnedTest.get(index);
            		String[] arrayString=existTestString.split("::");
            		String existTestPath=arrayString[0];
            		if(testPath.equals(existTestPath)) {
            			whetherExistedClass = true;
            			existTestString+="::";
            			existTestString+=testMethod;
            			returnedTest.set(index, existTestString);
            			break;
            		}	
            	}
            	if(whetherExistedClass==false) {
            		returnedTest.add(testString);
            	}
    		}
    	}
    	return returnedTest;
    }
    
    /**
     * Launch nopol with all tests added one by one on the project
     * @param destSrcTestFolder : location for the kept tests
     * @param destCpTestFolder : location to compile the kept tests
     * @param newTestFolder : location to generate news tests
     * @param classPath : name of class path
     * @param rootClassName : name of the class that contains the fix
     * @param orginalWorkDir : the temporary working directory
     */
    public static void tryRepairWithEvoSuite (int seed, String newTestFolder, String tempTestFolder, String destCpTestFolder, 
    		String transformedTestFoler, String classPath, String rootClassName, String orginalWorkDir, String destSrcTestFolder, String tempFailingTestFolder
    		, String tempCPFailingTestFolder, int allowedRepairTime, String testFolderSuccess, String testFolderNopolFast,String testFolderNopolSimple) {
    	
    	nopolFastRepairTime=0;
    	nopolSimpleRepairTime=0;
    	ArrayList<String> failingTests=getFailingTests();
    	failingTests=processFailingTests(failingTests);
    	String[] failingTestClasses= new String[failingTests.size()];
    	String[] passingTestClass = new String[1];
    	keptMethods.clear();
    	singleMethod.clear();
    	sucessMethod.clear();
    	
        //create dest folders if not exist
        new File(newTestFolder).mkdirs();
        new File(tempTestFolder).mkdirs();
        new File(tempFailingTestFolder).mkdirs();
        new File(tempCPFailingTestFolder).mkdirs();
        new File(transformedTestFoler).mkdirs();
        
        //runs EVoSuite to generate tests
        long evosuiteGeneratonTime = generateEvoSuiteTests(seed, newTestFolder, classPath, rootClassName);
        //gets the absolute path of the original class path
        String projectClasspathHere = getNewProjectPath (classPath, orginalWorkDir);
        
        copyFileBTweenDirectories(destSrcTestFolder,tempFailingTestFolder);
        copyFileBTweenDirectories(destCpTestFolder,tempCPFailingTestFolder);
        
        for (int testindex=failingTests.size()-1; testindex>=0; testindex--)
        {
        	String testString=failingTests.get(testindex);
        	String[] testInfo = testString.split("::");
        	String testPath= testInfo[0];
        	ArrayList<String> testMethod = new ArrayList<String>();
        	for(int number=1;number<testInfo.length;number++)
        		testMethod.add(testInfo[number]);
        	
        	failingTestClasses[testindex]=testPath;
        	String transformedTestPath = testPath.replaceAll("\\.", "/");   		    
        	String wholePath=destSrcTestFolder+transformedTestPath+".java";
            
            Launcher spoonLauncher = new Launcher();
            spoonLauncher.addProcessor(new ExtractFailingTestsProcessor(testMethod));
            spoonLauncher.addInputResource(wholePath);
            spoonLauncher.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
            spoonLauncher.setSourceOutputDirectory(destSrcTestFolder);
            spoonLauncher.getEnvironment().setShouldCompile(true);
            spoonLauncher.setBinaryOutputDirectory(destCpTestFolder);
            spoonLauncher.getEnvironment().setComplianceLevel(7);
            spoonLauncher.run();
        }
        
        Boolean whetherJdk8Test=false;
        Boolean whetherSuccesJunitTest=false;
        int discardedJDK8Tests=0;
        String finalPatchString="";
        long startTime = 0;
        long endTime = 0;
        int failingEvosuiteTests=0;
        //gets all JUnit methods
        List<CtMethod<?>> testsMethods = getNewTestsMethods(newTestFolder, projectClasspathHere);
        for(int methodIndex=0; methodIndex<testsMethods.size(); methodIndex++) {
        	
        	whetherJdk8Test=false;
        	whetherSuccesJunitTest=false;
        	CtMethod<?> method = testsMethods.get(methodIndex);
            logger.debug("# TEST METHOD : "+method.getSignature());
            singleMethod.add(method);
            
            logger.debug("### Remove EvoSuite &  Recompile Tests ");
            Launcher spoonLauncher = new Launcher();
            spoonLauncher.addProcessor(new TestSelectionProcessor(singleMethod));
            spoonLauncher.addProcessor(new RemoveEvosuiteEffectsProcessor());
            spoonLauncher.addInputResource(newTestFolder);
            spoonLauncher.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
            spoonLauncher.setSourceOutputDirectory(tempTestFolder);
            spoonLauncher.run();
            
            Launcher spoonLauncherAdditional = new Launcher();
            spoonLauncherAdditional.addInputResource(tempTestFolder);
            spoonLauncherAdditional.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
            spoonLauncherAdditional.setSourceOutputDirectory(transformedTestFoler);
            spoonLauncherAdditional.getEnvironment().setShouldCompile(true);
            spoonLauncherAdditional.setBinaryOutputDirectory(destCpTestFolder);
            spoonLauncherAdditional.getEnvironment().setComplianceLevel(7);
            try {
                spoonLauncherAdditional.run();
            }
            catch (ModelBuildingException e) {
            	whetherJdk8Test=true;
            	discardedJDK8Tests+=1;
    		}
            
            if (!whetherJdk8Test) {
            	
         	   String initiaPathOfEvosuiteTests= readfile(transformedTestFoler);
       		   String finalPathOfEvosuiteTests = processOrginalString (initiaPathOfEvosuiteTests); 
       		   passingTestClass[0]= finalPathOfEvosuiteTests;
       		   String commandString="";
       		   commandString += "export PATH=";
    		   commandString += Config.processPath(System.getenv("PATH"),7);
    		   commandString += " && ";
       		   commandString += "java -cp "+ projectClasspathHere+" org.junit.runner.JUnitCore "+finalPathOfEvosuiteTests;
       		  
               String[] cmd = { "/bin/bash", "-c", commandString};
       	       ProcessBuilder pb = new ProcessBuilder(cmd);
       	       pb.redirectErrorStream(true);
               Process p = null;
               try {
                   p = pb.start();
                   BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
                   StringBuilder builder = new StringBuilder();
                   String line = null;
                   while ((line = stdInput.readLine()) != null) {
                      builder.append(line);
                      builder.append(System.getProperty("line.separator"));
                   }
                   String result = builder.toString();
                   System.out.println(result);
                   if (result.indexOf("OK (1 test)")!=-1)
                	   whetherSuccesJunitTest=true;
                   else
                   {
                	   whetherSuccesJunitTest=false;
                	   failingEvosuiteTests+=1;
                   }
                   p.waitFor();
                } catch (IOException e1) {
                   e1.printStackTrace();
                } catch (InterruptedException e) {
                   e.printStackTrace();
                }
               
               if(whetherSuccesJunitTest==true)
               {
               	   sucessMethod.add(method);
               	   String[] testClasses;
               	   testClasses=concat(passingTestClass,failingTestClasses);
               	   String testString="";
                   for(int index=0;index<testClasses.length;index++)
               	   {
               		   testString+=testClasses[index];
               		   if(index!=(testClasses.length-1))
               				 testString+=":";
                   }
                   System.out.println(testString);
                   startTime=System.nanoTime();
              	   repairTool.run(toRepair, identifyNumber, false, false, false, testString, allowedRepairTime);
              	   endTime=System.nanoTime();
              	   nopolFastRepairTime+=(endTime-startTime);
               	   if(repairTool.whetherFindPatch()){
               		    logger.debug("### ----- PATCH FOUND -----");
                        logger.debug(repairTool.getPatchString());
                        keptMethods.add(method);
               	   }
                }
            }
           singleMethod.clear();
        }
        
        int consectiveSucessCount=0;
        int numberFlakyTests=0;
        while(consectiveSucessCount<5) {
        
        Launcher spoonLauncherRemoveFlaky = new Launcher();
        spoonLauncherRemoveFlaky.addProcessor(new TestSelectionProcessor(sucessMethod));
        spoonLauncherRemoveFlaky.addProcessor(new RemoveEvosuiteEffectsProcessor());
        spoonLauncherRemoveFlaky.addInputResource(newTestFolder);
        spoonLauncherRemoveFlaky.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
        spoonLauncherRemoveFlaky.setSourceOutputDirectory(transformedTestFoler);
        spoonLauncherRemoveFlaky.getEnvironment().setShouldCompile(true);
        spoonLauncherRemoveFlaky.setBinaryOutputDirectory(destCpTestFolder);
        spoonLauncherRemoveFlaky.getEnvironment().setComplianceLevel(7);
        spoonLauncherRemoveFlaky.run();
        
        String iniPathOfEvosuiteTests= readfile(transformedTestFoler);
		String finPathOfEvosuiteTests = processOrginalString (iniPathOfEvosuiteTests); 
		String commandString="";
   		commandString += "export PATH=";
		commandString += Config.processPath(System.getenv("PATH"),7);
		commandString += " && ";
		commandString += "java -cp "+ projectClasspathHere+" org.junit.runner.JUnitCore "+finPathOfEvosuiteTests;
		ArrayList<String> flakyTests = new ArrayList<String>();
		flakyTests.clear();
        String[] cmd = { "/bin/bash", "-c", commandString};
	    ProcessBuilder pb = new ProcessBuilder(cmd);
	    pb.redirectErrorStream(true);
        Process p = null;
        try {
            p = pb.start();
            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String line = "";
            while ((line = stdInput.readLine()) != null) {
               if(line.indexOf(" test")!=-1 && line.indexOf("OK ")==-1)
               {
            	   String[] splitted1 = line.split(" ");
            	   String[] splitted2 = splitted1[1].split("\\(");
            	   flakyTests.add(splitted2[0]);
               }
            }
            p.waitFor();
          } catch (IOException e1) {
            e1.printStackTrace();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
         if(flakyTests.size()==0)
        	 consectiveSucessCount+=1;
         else {
        	 consectiveSucessCount=0;
        	 numberFlakyTests+=flakyTests.size();
        	 List<CtMethod<?>> toRemoveSucessMethods = new ArrayList<CtMethod<?>>();
        	 toRemoveSucessMethods.clear();
        	 List<CtMethod<?>> toRemoveKeptMethods = new ArrayList<CtMethod<?>>();
        	 toRemoveKeptMethods.clear();
        	 for (int indexFlakyTest=0; indexFlakyTest<flakyTests.size();indexFlakyTest++)
        	 {
        		 String nameOfFlakyTest=flakyTests.get(indexFlakyTest);
        		 for(int sucessMethodIndex=0; sucessMethodIndex<sucessMethod.size(); sucessMethodIndex++)
        		 {
        			 if(sucessMethod.get(sucessMethodIndex).getSimpleName().contains(nameOfFlakyTest))
        				 toRemoveSucessMethods.add(sucessMethod.get(sucessMethodIndex));
        		 }
        		 for(int keptMethodIndex=0; keptMethodIndex<keptMethods.size(); keptMethodIndex++)
        		 {
        			 if(keptMethods.get(keptMethodIndex).getSimpleName().contains(nameOfFlakyTest))
        				 toRemoveKeptMethods.add(keptMethods.get(keptMethodIndex));
        		 }
        	 }
        	 sucessMethod.removeAll(toRemoveSucessMethods);
        	 keptMethods.removeAll(toRemoveKeptMethods);
          }
        }
        
        copyFileBTweenDirectories(tempFailingTestFolder, destSrcTestFolder);
        copyFileBTweenDirectories(tempCPFailingTestFolder, destCpTestFolder);
        
        Launcher spoonLauncherFinal = new Launcher();
        spoonLauncherFinal.addProcessor(new TestSelectionProcessor(keptMethods));
        spoonLauncherFinal.addProcessor(new RemoveEvosuiteEffectsProcessor());
        spoonLauncherFinal.addInputResource(newTestFolder);
        spoonLauncherFinal.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
        spoonLauncherFinal.setSourceOutputDirectory(destSrcTestFolder);
        spoonLauncherFinal.getEnvironment().setShouldCompile(true);
        spoonLauncherFinal.setBinaryOutputDirectory(destCpTestFolder);
        spoonLauncherFinal.getEnvironment().setComplianceLevel(7);
        spoonLauncherFinal.run();
        
         startTime=System.nanoTime();
         repairTool.run(toRepair, identifyNumber, false, false, true, null, maximalRepairTime);
         endTime=System.nanoTime();
   	     nopolFastRepairTime+=(endTime-startTime);
         if(repairTool.whetherFindPatch()){
          logger.debug("### ----- PATCH FOUND -----");
          logger.debug(repairTool.getPatchString());
          finalPatchString = repairTool.getPatchString();
        }
         
        long evoRepairTime = nopolFastRepairTime/1000000;
        int nbRemovedMethod = testsMethods.size()-keptMethods.size();
        logEvosuiteRepairInfo(seed, testsMethods.size(),evosuiteGeneratonTime/1000000,evoRepairTime,
        		nbRemovedMethod,discardedJDK8Tests, finalPatchString, failingEvosuiteTests, numberFlakyTests, "Enopol-fast");
        
        Launcher spoonLauncherSuccess = new Launcher();
        spoonLauncherSuccess.addProcessor(new TestSelectionProcessor(sucessMethod));
        spoonLauncherSuccess.addProcessor(new RemoveEvosuiteEffectsProcessor());
        spoonLauncherSuccess.addInputResource(newTestFolder);
        spoonLauncherSuccess.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
        spoonLauncherSuccess.setSourceOutputDirectory(testFolderSuccess);
        spoonLauncherSuccess.run();
        
        Launcher spoonLauncherFast = new Launcher();
        spoonLauncherFast.addProcessor(new TestSelectionProcessor(keptMethods));
        spoonLauncherFast.addProcessor(new RemoveEvosuiteEffectsProcessor());
        spoonLauncherFast.addInputResource(newTestFolder);
        spoonLauncherFast.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
        spoonLauncherFast.setSourceOutputDirectory(testFolderNopolFast);
        spoonLauncherFast.run();
        
        /*
         * repair result using Enopol-simple
         */
    	keptMethods.clear();
    	finalPatchString= initialPatchString;
        List<CtMethod<?>> sortedTestsMethods = sortMethods(sucessMethod);
        
        for(int methodIndex=0; methodIndex<sortedTestsMethods.size(); methodIndex++) {
        	
        	System.out.println(sortedTestsMethods.get(methodIndex).getSimpleName());
        	CtMethod<?> method = sortedTestsMethods.get(methodIndex);
            logger.debug("# TEST METHOD : "+method.getSignature());
            keptMethods.add(method);
            System.out.println(keptMethods.size());
            logger.debug("### Remove EvoSuite &  Recompile Tests ");
            Launcher spoonLauncher = new Launcher();
            spoonLauncher.addProcessor(new TestSelectionProcessor(keptMethods));
            spoonLauncher.addProcessor(new RemoveEvosuiteEffectsProcessor());
            spoonLauncher.addInputResource(newTestFolder);
            spoonLauncher.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
            spoonLauncher.setSourceOutputDirectory(destSrcTestFolder);
            spoonLauncher.getEnvironment().setShouldCompile(true);
            spoonLauncher.setBinaryOutputDirectory(destCpTestFolder);
            spoonLauncher.getEnvironment().setComplianceLevel(7);
            spoonLauncher.run();
            
            logger.debug("### Launch Nopol");
            startTime=System.nanoTime();
            repairTool.run(toRepair, identifyNumber, false, false, true, null, allowedRepairTime);
            endTime=System.nanoTime();
            nopolSimpleRepairTime+=(endTime-startTime);
            if(repairTool.whetherFindPatch()){
                  logger.debug("### ----- PATCH FOUND -----");
                  logger.debug(repairTool.getPatchString());
                  finalPatchString = repairTool.getPatchString();
                  logger.debug("### METHOD KEPT : "+method.getSignature());
             }
             else {
                  logger.debug("### ----- NO PATCH FOUND -----");
                  logger.debug("### METHOD REMOVED : "+method.getSignature());
                  keptMethods.remove(method);
             }
         }       
        
        long evoRepairTime2 = nopolSimpleRepairTime/1000000;
        int nbRemovedMethod2 = sortedTestsMethods.size()-keptMethods.size();
        logEvosuiteRepairInfo(seed, sortedTestsMethods.size(),evosuiteGeneratonTime/1000000, evoRepairTime2,
        		nbRemovedMethod2, discardedJDK8Tests, finalPatchString, failingEvosuiteTests, numberFlakyTests, "Enopol-simple");
        
        Launcher spoonLauncherSimple = new Launcher();
        spoonLauncherSimple.addProcessor(new TestSelectionProcessor(keptMethods));
        spoonLauncherSimple.addProcessor(new RemoveEvosuiteEffectsProcessor());
        spoonLauncherSimple.addInputResource(newTestFolder);
        spoonLauncherSimple.getEnvironment().setSourceClasspath(projectClasspathHere.split(File.pathSeparator));
        spoonLauncherSimple.setSourceOutputDirectory(testFolderNopolSimple);
        spoonLauncherSimple.run();
            
    }
    
    @SuppressWarnings("null")
	public static List<CtMethod<?>> sortMethods (List<CtMethod<?>> orginalMethods) {
    	
    	List<CtMethod<?>> sortedMethod = new ArrayList<CtMethod<?>>();
    	int[] methodNameArray=new int[orginalMethods.size()];
    	int[] numberIndex=new int[orginalMethods.size()];
    	String methodName;
    	for (int index=0; index<orginalMethods.size();index++) {
    		methodName = orginalMethods.get(index).getSimpleName();
    		methodName = methodName.replace("test", "");
    		methodName = methodName.replace("\\(\\)", "");
    		while(methodName.startsWith("0")) {
    			methodName = methodName.replaceFirst("0", "");
    		}
    		if(methodName.isEmpty())
    		   methodNameArray[index] = 0;
    		else 
    		   methodNameArray[index] = Integer.parseInt(methodName);
    		
    		numberIndex[index]=index;
    	}
    	int j;
        boolean flag = true; 
        int temp; 
        while(flag){
            flag= false;  
            for(j=0;j<methodNameArray.length-1;j++ ){
                if (methodNameArray[j] > methodNameArray[j+1] ) {
                      temp = methodNameArray[j];   
                      methodNameArray[j] = methodNameArray[j+1];
                      methodNameArray[j+1] = temp;
                      temp = numberIndex[j];
                      numberIndex[j]= numberIndex[j+1];
                      numberIndex[j+1]=temp;
                      flag = true;  
                }
           }
        } 
        for (int index=0; index<numberIndex.length;index++) {
        	sortedMethod.add(orginalMethods.get(numberIndex[index]));
    	}  
    	return sortedMethod;
    }
    
    public static void copyFileBTweenDirectories(String orginalDirectory, String destDirectory) {

		File sourceDirectory = new File(orginalDirectory);
		File destinationDirectory = new File(destDirectory);
		try {
			FileUtils.copyDirectory(sourceDirectory, destinationDirectory);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
    
    public static String readfile(String filepath)  {
    	
          File file = new File(filepath);
		  if (!file.isDirectory()) {
			    if(file.getAbsolutePath().contains("_ESTest")&&!file.getAbsolutePath().contains("_scaffolding"))
			    {
			    	testPath = file.getAbsolutePath();
			    	return testPath;
			    }
		  } else if (file.isDirectory()) {
		        String[] filelist = file.list();
		        for (int i = 0; i < filelist.length; i++) {
		               File readfile = new File(filepath + "/" + filelist[i]);
		               if (!readfile.isDirectory()) {
		            	   if(readfile.getAbsolutePath().contains("_ESTest")&&!readfile.getAbsolutePath().contains("_scaffolding"))
		   			       {
		            		  testPath = readfile.getAbsolutePath();
		   			    	  return testPath;
		   			       }
		               } else if (readfile.isDirectory()) {
		                    readfile(filepath + "/" + filelist[i]);
		               }
		         }
		  }
        return testPath;
     }   
}
